# Java 并发编程

## Maven 自动化管理工具

### Maven 简介

Maven是一个项目自动化构建工具。

1.  完成项目的工作：

	-   分析项目要做什么，知道项目的组成部分
	-   设计项目，通过哪些步骤，使用哪些步骤，需要多少人，多长的时间
	-   组建团队与设备
	-   开发人员写代码，测试代码，重复多次的工作
	-   测试人员，测试项目功能是否符合要求，直到测试代码通过

2.  传统开发项目的问题

    -   很多模块，模块之间有关系，手工管理较为繁琐
    -   需要很多第三方功能，需要很多jar包，手动获取
    -   需要管理jar包版本
    -   管理jar文件之间的依赖
    
3.  需要改进项目的开发和管理，可以使用maven

    -   管理jar文件
    -   自动下载jar及其文档、源代码
    -   管理jar包之间的依赖
    -   管理jar包的版本
    -   编译程序，把java编译为class
    -   测试代码是否正确
    -   打包文件，形成jar文件或war文件
    -   部署项目

4.  构建：项目的构建

    -   构建是面向过程的，就是一些步骤，完成项目代码的编译、测试、运行、打包、部署等

    -   maven支持的构建：

        1）清理：把之前项目编译的东西删掉，为新的编译代码做准备

        2）编译：把程序源代码编译为可执行代码，批量操作

        3）测试：maven可以执行测试程序代码，验证功能是否正确，批量操作

        4）报告：生成测试结果的文件

        5）打包：把项目中所有资源打包成项目的结果文件（jar包或者war包）

        6）安装：把jar文件或war文件安装到本地仓库

        7）部署：把程序安装好可以执行

5.  maven的核心概念

    -   POM：一个文件pom.xml，项目对象模型，maven把一个项目当做一个模型使用，可以控制maven构建项目的过程，管理jar依赖。
    -   约定的目录结构：maven项目的目录和文件的位置是有规定的。
    -   坐标：是一个唯一的字符串，用来表示资源的。
    -   依赖管理：管理项目中可以使用的jar文件。
    -   仓库管理：资源存放的位置
    -   生命周期：maven构建项目的过程
    -   插件和目标：执行maven构建的时候用的工具是插件
    -   继承
    -   聚合

6.  maven工具的安装和配置

### Maven的核心概念

1.  maven的约定目录结构
```
    Hello（项目名）
		|---src
		|---|---main（主程序）
		|---|---|---java（主程序中的包和包中java文件）
		|---|---|---resources（主程序中要使用的配置文件）
		|---|---test（测试代码和文件，可以没有）
		|---|---|---java（测试程序中的包和包中java文件）
		|---|---|---resources（测试程序中要使用的配置文件）
		|---pom.xml（核心文件）
```

每一个maven项目在磁盘中都是一个文件夹

2.  `mvn compile`编译src/main目录下的所有java文件

    在项目的根目录下会生成target目录（结果目录）

3.  仓库

    -   仓库是存放maven使用的jar包和项目所使用的jar包

    -   分类

        1）本地仓库：个人计算机上的文件夹

        2）远程仓库：互联网上，需要网络才能使用的仓库

        -   中央仓库：最权威的，所有的开发人员共享使用的集中仓库
        -   中央仓库镜像：在各大洲重要的城市都有镜像
        -   私服：内部局域网中使用

    -   使用：不需要人为参与

        开发人员需要使用->maven查本地仓库->私服->镜像->中央仓库

4.  pom：项目对象模型

    pom.xml

    https://mvnrepository.com/ 中央仓库

    | **基本信息**             |                                                              |                                                              |
    | ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | modelVersion             | Maven模型的版本，对于Maven2和Maven3而言只能是4.0.0           |                                                              |
    | groupId                  | 组织id，一般是公司域名的缩写，格式可以为：1. 域名倒写 2.域名倒写+项目名 | groupId、artifactId、version三个元素生成了一个Maven项目的基本坐标，在众多的maven项目中可以唯一定位到某一个项目，坐标也决定将来项目在仓库中的路径及名称 |
    | artifactId               | 项目名称，也是模块名称，对应groupId中项目的子项目            |                                                              |
    | version                  | 项目的版本号，如果项目还在开发中是不稳定版本，通常在版本后带-SNAPSHOT， version使用三位数字标识，如1.0.0 |                                                              |
    | packaging                | 项目打包的类型，可以是jar、war、rar、ear、pom，默认是jar     |                                                              |
    | **依赖**                 |                                                              |                                                              |
    | dependencies和dependency | maven的一个重要作用就是管理jar包，为了一个项目可以构建或运行，项目中不可避免地会依赖很多其他的jar包，在maven中这些jar就称为依赖，使用标签dependency来配置 |                                                              |
    | **配置属性**             |                                                              |                                                              |
    | properties               | properties用来定义一些配置属性，例如project.build.sourceEncoding，可以设置为UTF-8，防止中文乱码，也可定义相关构建版本号，便于日后统一升级 |                                                              |
    | **构建**                 |                                                              |                                                              |
    | build                    | 表示与构建相关的配置，例如设置编译插件的jdk版本              |                                                              |
    | **继承**                 |                                                              |                                                              |
    | parent                   | 在maven中，如果多个模块都需要声明相同的配置，例如groupid、version、有相同的依赖、或者相同的组件配置等，也有类似Java的继承机制，用parent声明要继承的父工程的pom配置 |                                                              |
    | **聚合**                 |                                                              |                                                              |
    | modules                  | 在maven的多模块开发中，为了同一构建整个项目的所有模块，可以提供一个额外的模块，该模块打包方式为pom，并且在其中使用modules聚合的其他模块，这样通过本模块就可以一键自动识别模块间的依赖关系来构建所有模块，叫maven的聚合。 |                                                              |

5.  maven的常用命令

    -   `mvn clean`：清理
    -   `mvn compile`：编译主程序
    -   `mvn test-compile`：编译测试程序
    -   `mvn test`：测试
    -   `mvn package`：打包主程序
    -   `mvn install`：安装主程序
	-   `mvn deploy`：部署主程序
    

注意：必须在命令行进入pom.xml所在目录
-   maven的生命周期：maven构建项目的过程（清理、编译、测试、报告、打包、安装、部署）
-   maven的插件：maven命令执行时真正完成功能的是插件，插件是一些jar文件

### 依赖管理

`scope`指依赖范围，值有compile（默认）、test、provided，在maven构建项目的哪些阶段起作用。

|                    | compile | test | provided |
| ------------------ | ------- | ---- | -------- |
| 对主程序是否有效   | YES     | NO   | YES      |
| 对测试程序是否有效 | YES     | YES  | YES      |
| 是否参与打包       | YES     | NO   | NO       |
| 是否参与部署       | YES     | NO   | NO       |

### Maven常用设置

-   全局变量

Maven的pom.xml文件中，`<properties>`用于定义全局变量，POM中通过`${property_name}`的形式引用变量的值。

定义全局变量：

```xml
<properties>
    <spring.version>4.3.10.RELEASE</spring.version>
</properties>
```

引用全局变量

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>${spring.version}</version>
</dependency>
```

Maven系统采用的变量

```xml
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
</properties>
```

-   指定资源位置

```xml
<build>
	<resources>
    	<directory>src/main/java</directory><!--所在的目录-->
        <includes><!--包括目录下的.properties，.xml文件都会扫描到-->
        	<include>**/*.properties</include>
            <include>**/*.xml</include>
        </includes>
        <filtering>false</filtering>
    </resources>
</build>
```

作用：

1.  默认没有使用resources，maven执行编译代码时会把src/main/resource目录中的文件拷贝到target/classes目录中，对于src/main/java目录下的非java文件不处理，不拷贝到target/classes目录中
2.  程序把一些文件放在src/main/java目录中，当执行java程序时需要用到src/main/java目录中的文件，要告诉maven在`mvn compile src/main/java`目录下的程序时，需要把文件一同拷贝到target/classes目录中，此时就需要在`<build>`中加入`<resources>`

## 进程和线程

-   JUC简介

    java.util工具包

    业务：普通的线程代码 Thread

    Runnable：没有返回值，效率相比Callable低

进程：一个程序，程序的集合

一个进程可以包含多个线程，至少包含一个线程

java默认有两个线程（main、gc）

Thread、Runnable、Callable可以开启线程

**java真的可以开启线程吗？开不了**

```java
    public synchronized void start() {
        if (this.threadStatus != 0) {
            throw new IllegalThreadStateException();
        } else {
            this.group.add(this);
            boolean started = false;

            try {
                this.start0();
                started = true;
            } finally {
                try {
                    if (!started) {
                        this.group.threadStartFailed(this);
                    }
                } catch (Throwable var8) {
                }

            }

        }
    }

    private native void start0();
```

start0是本地方法，调用底层C++，Java无法直接操作硬件。

-   并发和并行

    并发：多线程操作同一个资源，CPU单核交替运行

    并行：CPU多核，多个线程可以同时执行

    ```java
    public static void main(String[] args) {
        System.out.println(Runtime.getRuntime().availableProcessors());//获取CPU核数
    }
    ```

    并发编程的本质：充分利用CPU的资源

-   线程的状态

    ```java
    public static enum State {
            NEW,//新生
            RUNNABLE,//运行
            BLOCKED,//阻塞
            WAITING,//等待
            TIMED_WAITING,//超时等待
            TERMINATED;//终止
    
            private State() {
            }
        }
    ```

-   wait、sleep区别

    1.  来自不同的类：wait来自Object类，sleep来自Thread类
    2.  wait会释放锁，sleep不会释放锁
    3.  使用范围不同：wait必须在同步代码块中，sleep可以在任何地方
    4.  是否要捕获异常：wait不需要捕获异常，sleep必须要捕获异常

## Lock锁

-   传统Synchronized锁

    ```java
    public class CMain {
        public static void main(String[] args) {
            Ticket ticket=new Ticket();
            new Thread(() -> {
                for(int i=1;i<40;i++) ticket.sell();},"A").start();
            new Thread(() -> {
                for(int i=1;i<40;i++) ticket.sell();},"B").start();
            new Thread(() -> {
                for(int i=1;i<40;i++) ticket.sell();},"C").start();
        }
    }
    class Ticket{
        private int number=50;
        public synchronized void sell(){
            if(number>0) {
                System.out.print(Thread.currentThread().getName());
                System.out.println("卖出了"+number+"张票，剩余"+(number--)+"张");
            }
        }
    }
    ```

    