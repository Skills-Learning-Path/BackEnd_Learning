# Java程序连接Redis

## Jedis

1.  导入依赖

    ```xml
    <!-- https://mvnrepository.com/artifact/redis.clients/jedis -->
        <dependency>
          <groupId>redis.clients</groupId>
          <artifactId>jedis</artifactId>
          <version>3.2.0</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/com.alibaba/fastjson -->
        <dependency>
          <groupId>com.alibaba</groupId>
          <artifactId>fastjson</artifactId>
          <version>1.2.70</version>
        </dependency>
    ```

2.  连接数据库

3.  操作命令

4.  断开连接

```java
public static void main( String[] args )  {
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        System.out.println(jedis.ping());//测试连接
    }
```

## 常用API

1.  对String操作的命令

   set(key, value)：给数据库中名称为key的string赋予值value

   get(key)：返回数据库中名称为key的string的value

   getset(key, value)：给名称为key的string赋予上一次的value

   mget(key1, key2,…, key N)：返回库中多个string（它们的名称为key1，key2…）的value

   setnx(key, value)：如果不存在名称为key的string，则向库中添加string，名称为key，值为value

   setex(key, time, value)：向库中添加string（名称为key，值为value）同时，设定过期时间time

   mset(key1, value1, key2, value2,…key N, value N)：同时给多个string赋值，名称为key i的string赋值value i

   msetnx(key1, value1, key2, value2,…key N, value N)：如果所有名称为key i的string都不存在，则向库中添加string，名称key i赋值为value i

   incr(key)：名称为key的string增1操作

   incrby(key, integer)：名称为key的string增加integer

   decr(key)：名称为key的string减1操作

   decrby(key, integer)：名称为key的string减少integer

   append(key, value)：名称为key的string的值附加value

   substr(key, start, end)：返回名称为key的string的value的子串

2.  对List操作的命令

   rpush(key, value)：在名称为key的list尾添加一个值为value的元素

   lpush(key, value)：在名称为key的list头添加一个值为value的 元素

   llen(key)：返回名称为key的list的长度

   lrange(key, start, end)：返回名称为key的list中start至end之间的元素（下标从0开始，下同）

   ltrim(key, start, end)：截取名称为key的list，保留start至end之间的元素

   lindex(key, index)：返回名称为key的list中index位置的元素

   lset(key, index, value)：给名称为key的list中index位置的元素赋值为value

   lrem(key, count, value)：删除count个名称为key的list中值为value的元素。count为0，删除所有值为value的元素，count>0    从头至尾删除count个值为value的元素，count<0从尾到头删除|count|个值为value的元素。

   lpop(key)：返回并删除名称为key的list中的首元素

   rpop(key)：返回并删除名称为key的list中的尾元素

   blpop(key1, key2,… key N, timeout)：lpop 命令的block版本。即当timeout为0时，若遇到名称为key i的list不存在或该list为空，则命令结束。如果 timeout>0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对key i+1开始的list执行pop操作。

   brpop(key1, key2,… key N, timeout)：rpop的block版本。参考上一命令。

   rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部

3.  对Set操作的命令

   sadd(key, member)：向名称为key的set中添加元素member

   srem(key, member) ：删除名称为key的set中的元素member

   spop(key) ：随机返回并删除名称为key的set中一个元素

   smove(srckey, dstkey, member) ：将member元素从名称为srckey的集合移到名称为dstkey的集合

   scard(key) ：返回名称为key的set的基数

   sismember(key, member) ：测试member是否是名称为key的set的元素

   sinter(key1, key2,…key N) ：求交集

   sinterstore(dstkey, key1, key2,…key N) ：求交集并将交集保存到dstkey的集合

   sunion(key1, key2,…key N) ：求并集

   sunionstore(dstkey, key1, key2,…key N) ：求并集并将并集保存到dstkey的集合

   sdiff(key1, key2,…key N) ：求差集

   sdiffstore(dstkey, key1, key2,…key N) ：求差集并将差集保存到dstkey的集合

   smembers(key) ：返回名称为key的set的所有元素

   srandmember(key) ：随机返回名称为key的set的一个元素

4.  对zset（sorted set）操作的命令

   zadd(key, score, member)：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。

   zrem(key, member) ：删除名称为key的zset中的元素member

   zincrby(key, increment, member) ：如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment

   zrank(key, member) ：返回名称为key的zset（元素已按score从小到大排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”

   zrevrank(key, member) ：返回名称为key的zset（元素已按score从大到小排序）中member元素的rank（即index，从0开始），若没有member元素，返回“nil”

   zrange(key, start, end)：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素

   zrevrange(key, start, end)：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素

   zrangebyscore(key, min, max)：返回名称为key的zset中score >= min且score <= max的所有元素

   zcard(key)：返回名称为key的zset的基数

   zscore(key, element)：返回名称为key的zset中元素element的score

   zremrangebyrank(key, min, max)：删除名称为key的zset中rank >= min且rank <= max的所有元素

   zremrangebyscore(key, min, max) ：删除名称为key的zset中score >= min且score <= max的所有元素

   zunionstore / zinterstore(dstkeyN, key1,…,keyN, WEIGHTS w1,…wN, AGGREGATE SUM|MIN|MAX)：对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行 SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。

5.对Hash操作的命令

   hset(key, field, value)：向名称为key的hash中添加元素field<—>value

   hget(key, field)：返回名称为key的hash中field对应的value

   hmget(key, field1, …,field N)：返回名称为key的hash中field i对应的value

   hmset(key, field1, value1,…,field N, value N)：向名称为key的hash中添加元素field i<—>value i

   hincrby(key, field, integer)：将名称为key的hash中field的value增加integer

   hexists(key, field)：名称为key的hash中是否存在键为field的域

   hdel(key, field)：删除名称为key的hash中键为field的域

   hlen(key)：返回名称为key的hash中元素个数

   hkeys(key)：返回名称为key的hash中所有键

   hvals(key)：返回名称为key的hash中所有键对应的value

   hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value

6.  对value操作的命令

   exists(key)：确认一个key是否存在

   del(key)：删除一个key

   type(key)：返回值的类型

   keys(pattern)：返回满足给定pattern的所有key

   randomkey：随机返回key空间的一个key

   rename(oldname, newname)：将key由oldname重命名为newname，若newname存在则删除newname表示的key

   dbsize：返回当前数据库中key的数目

   expire：设定一个key的活动时间（s）

   ttl：获得一个key的活动时间

   select(index)：按索引查询

   move(key, dbindex)：将当前数据库中的key转移到有dbindex索引的数据库

   flushdb：删除当前选择数据库中的所有key

   flushall：删除所有数据库中的所有key

-   示例代码

```java
public static void main( String[] args )  {
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        System.out.println(jedis.flushDB());
        System.out.println(jedis.exists("username"));
        System.out.println(jedis.set("username", "abc"));
        System.out.println(jedis.get("username"));
        System.out.println(jedis.keys("*"));
        System.out.println(jedis.del("username"));
    	jedis.close();
    }
```

## 事务

```java
public static void main( String[] args )  {
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        jedis.flushDB();
        Transaction transaction = jedis.multi();
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("hello","111");
        jsonObject.put("name","222");
        String result = jsonObject.toString();
        try {
            transaction.set("user",result);
            transaction.set("kkk",result);
            transaction.exec();
        }
        catch (Exception e){
            transaction.discard();
            e.printStackTrace();
        }
        finally {
            System.out.println(jedis.get("user"));
            System.out.println(jedis.get("kkk"));
            jedis.close();
        }
    }
```

## 整合SpringBoot

SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！

SpringData 也是和 SpringBoot 齐名的项目！

说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?

jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式

lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式

源码分析：

```java
@Bean
@ConditionalOnMissingBean(name = "redisTemplate") 
// 我们可以自己定义一个redisTemplate来替换这个默认的！
public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {
// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！
// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 <String, Object>
    RedisTemplate<Object, Object> template = new RedisTemplate<>();
    template.setConnectionFactory(redisConnectionFactory);
    return template;
}
@Bean
@ConditionalOnMissingBean // 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！
public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {
    StringRedisTemplate template = new StringRedisTemplate();
    template.setConnectionFactory(redisConnectionFactory);
    return template;
}
```

**整合测试**

1.导入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。

jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式

lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式

我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。

[![img](.\res\15.png)]()

那么就一定还存在一个RedisProperties类

[![img](.\res\16.png)]()

@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的

然后再看Lettuce：

[![img](.\res\17.png)]()

完美生效。

现在我们回到RedisAutoConfiguratio

[![img](.\res\18.webp)]()

只有两个简单的Bean

- RedisTemplate
- StringRedisTemplate

当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。

在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的

说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties

[![img](.\res\19.png)]()

这是一些基本的配置属性。

[![img](.\res\20.webp)]()

还有一些连接池相关的配置。注意使用时一定使用**Lettuce**的连接池。

[![img](.\res\21.webp)]()

2.编写配置文件

```properties

spring.redis.host=39.99.xxx.xx
spring.redis.port=6379
```

3.使用RedisTemplate

```java
@SpringBootTest
class Redis02SpringbootApplicationTests {
@Autowired
private RedisTemplate redisTemplate;

@Test
void contextLoads() {

    // redisTemplate 操作不同的数据类型，api和我们的指令是一样的
    // opsForValue 操作字符串 类似String
    // opsForList 操作List 类似List
    // opsForSet
    // opsForHash
    // opsForZSet
    // opsForGeo
    // opsForHyperLog

    // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD

    // 获取连接对象
    //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();
    //connection.flushDb();
    //connection.flushAll();

    redisTemplate.opsForValue().set("mykey","kuangshen");
    System.out.println(redisTemplate.opsForValue().get("mykey"));
}

}

```



4.测试结果

此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出。这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。

RedisTemplate内部的序列化配置是这样的

[![img](.\res\22.webp)]()

默认的序列化器是采用JDK序列化器

[![img](.\res\23.webp)]()

后续我们定制RedisTemplate就可以对其进行修改。

RedisSerializer提供了多种序列化方案：

[![img](.\res\24.webp)]()

我们来编写一个自己的 RedisTemplete



```java
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
@Configuration
public class RedisConfig {
    // 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用！
    // 自己定义了一个 RedisTemplate
    @Bean
    @SuppressWarnings("all")
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        // 我们为了自己开发方便，一般直接使用 <String, Object>
        RedisTemplate<String, Object> template = new RedisTemplate<String,
        Object>();
        template.setConnectionFactory(factory);
    // Json序列化配置
    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new
    Jackson2JsonRedisSerializer(Object.class);
    ObjectMapper om = new ObjectMapper();
    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
    om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
    jackson2JsonRedisSerializer.setObjectMapper(om);
    // String 的序列化
    StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();

    // key采用String的序列化方式
    template.setKeySerializer(stringRedisSerializer);
    // hash的key也采用String的序列化方式
    template.setHashKeySerializer(stringRedisSerializer);
    // value序列化方式采用jackson
    template.setValueSerializer(jackson2JsonRedisSerializer);
    // hash的value序列化方式采用jackson
    template.setHashValueSerializer(jackson2JsonRedisSerializer);
    template.afterPropertiesSet();

    return template;
}

}



```





所有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数据结构的用处和作用场景！